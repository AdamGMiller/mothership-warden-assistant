<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mothership Map</title>
    <style>
      body {
        margin: 0;
        background-color: #002200;
        overflow: hidden;
      }

      .map-container {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        position: relative;
        cursor: grab;
      }

      .map-container:active {
        cursor: grabbing;
      }

      #content {
        position: absolute;
        top: 0;
        left: 0;
        transform-origin: top left;
        will-change: transform;
      }

      canvas#mapCanvas {
        image-rendering: pixelated;
        filter: drop-shadow(0 0 1px #0f0) drop-shadow(0 0 2px #0f0);
        animation: pulseGlow 3.5s ease-in-out infinite;
        display: block;
      }

      /* CRT EFFECTS stay fixed on top of viewport */
      .crt-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        z-index: 10;
      }

      .overlay-scanlines {
        background: repeating-linear-gradient(
          to bottom,
          rgba(0, 255, 0, 0.03) 0px,
          rgba(0, 255, 0, 0.03) 1px,
          transparent 1px,
          transparent 3px
        );
        width: 100%;
        height: 100%;
      }

      .overlay-flicker {
        background-color: rgba(0, 255, 0, 0.02);
        animation: flicker 0.15s infinite;
        width: 100%;
        height: 100%;
      }

      .overlay-glow {
        background: radial-gradient(
            circle at center,
            rgba(0, 255, 0, 0.08) 0%,
            rgba(0, 255, 0, 0.01) 70%,
            rgba(0, 255, 0, 0) 100%
          ),
          radial-gradient(
            circle at center,
            rgba(0, 0, 0, 0) 50%,
            rgba(0, 0, 0, 0.15) 100%
          );
        mix-blend-mode: screen;
        width: 100%;
        height: 100%;
      }

      canvas#noise {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 4;
        opacity: 0.04;
        mix-blend-mode: screen;
        pointer-events: none;
      }

      @keyframes flicker {
        0%,
        100% {
          opacity: 0.01;
        }

        50% {
          opacity: 0.03;
        }
      }

      @keyframes pulseGlow {
        0%,
        100% {
          filter: drop-shadow(0 0 1px #0f0) drop-shadow(0 0 2px #0f0);
        }

        50% {
          filter: drop-shadow(0 0 1.5px #0f0) drop-shadow(0 0 3px #0f0);
        }
      }

      #loading-spinner {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #002200;
        color: #00ff00;
        border: 2px solid #00ff00;
        padding: 16px 32px;
        font-family: monospace;
        font-size: 18px;
        z-index: 30;
        display: none;
        box-shadow: 0 0 10px #00ff00;
        animation: blink 1s step-start infinite;
      }

      @keyframes blink {
        50% {
          opacity: 0.3;
        }
      }
    </style>
  </head>

  <body>
    <div id="loading-spinner">LOADING...</div>
    <!-- Zoom/Pan container with image -->
    <div class="map-container" id="mapContainer">
      <div id="content">
        <canvas id="mapCanvas"></canvas>
      </div>
    </div>
    <!-- CRT EFFECTS STAY FIXED -->
    <div class="crt-overlay">
      <div class="overlay-glow"></div>
      <div class="overlay-scanlines"></div>
      <div class="overlay-flicker"></div>
      <canvas id="noise"></canvas>
    </div>

    <script>
      const mapCanvas = document.getElementById("mapCanvas");
      const ctx = mapCanvas.getContext("2d");
      const content = document.getElementById("content");
      const mapContainer = document.getElementById("mapContainer");

      const noiseCanvas = document.getElementById("noise");
      const noiseCtx = noiseCanvas.getContext("2d");

      let scale = 1;
      let originX = 0;
      let originY = 0;
      let isDragging = false;
      let startX, startY;
      let lastTouchDistance = null;
      let isTouchPanning = false;
      let lastTouchMidpoint = { x: 0, y: 0 };

      const img = new Image();
      img.crossOrigin = "anonymous";

      // Get the map image from the query parameter
      const urlParams = new URLSearchParams(window.location.search);
      const mapImage = urlParams.get("map");

      function loadMapImage(src) {
        document.getElementById("loading-spinner").style.display = "block";
        img.src = src;
        originX = 0;
        originY = 0;
        scale = 1;
      }

      img.onload = () => {
        mapCanvas.width = img.width;
        mapCanvas.height = img.height;

        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
          const r = data[i],
            g = data[i + 1],
            b = data[i + 2];
          const isBlack = r < 100 && g < 100 && b < 100;
          const isGray = !isBlack && r < 230 && g < 230 && b < 230;
          if (isBlack) {
            data[i] = 0; // R
            data[i + 1] = 255; // G
            data[i + 2] = 0; // B
            data[i + 3] = 255; // Fully opaque
          } else if (isGray) {
            data[i] = 0; // R
            data[i + 1] = 255; // G
            data[i + 2] = 0; // B
            data[i + 3] = 20; // Semi-transparent
          } else {
            data[i + 3] = 0; // Transparent
          }
        }

        ctx.putImageData(imageData, 0, 0);

        // Fit image to screen on load
        const containerWidth = mapContainer.clientWidth;
        const containerHeight = mapContainer.clientHeight;
        console.log(containerWidth, containerHeight);

        const scaleX = containerWidth / img.width;
        const scaleY = containerHeight / img.height;
        console.log(scaleX, scaleY);

        scale = Math.min(scaleX, scaleY);
        console.log(scale);
        originX = (containerWidth - img.width * scale) / 2;
        originY = (containerHeight - img.height * scale) / 2;

        updateTransform();

        document.getElementById("loading-spinner").style.display = "none";
      };

      // Load the map image passed in the query parameter
      if (mapImage) {
        loadMapImage(mapImage);
      } else {
        console.error("No map image provided in query parameters.");
      }

      function updateTransform() {
        content.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
      }

      // Pan + Zoom
      mapContainer.addEventListener("mousedown", (e) => {
        isDragging = true;
        startX = e.clientX - originX;
        startY = e.clientY - originY;
      });

      mapContainer.addEventListener("mouseup", () => (isDragging = false));
      mapContainer.addEventListener("mouseleave", () => (isDragging = false));
      mapContainer.addEventListener("mousemove", (e) => {
        if (isDragging) {
          originX = e.clientX - startX;
          originY = e.clientY - startY;
          updateTransform();
        }
      });

      mapContainer.addEventListener("wheel", (e) => {
        e.preventDefault();
        const scaleFactor = 1.1;
        const rect = mapContainer.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Calculate the position in the image coordinate space before scaling
        const imgX = (mouseX - originX) / scale;
        const imgY = (mouseY - originY) / scale;

        // Update the scale
        if (e.deltaY < 0) {
          scale *= scaleFactor;
        } else {
          scale /= scaleFactor;
        }

        // Adjust origin so the point under the mouse stays in the same screen position
        originX = mouseX - imgX * scale;
        originY = mouseY - imgY * scale;
        updateTransform();
      });

      mapContainer.addEventListener("touchstart", (e) => {
        if (e.touches.length === 2) {
          e.preventDefault();
          isTouchPanning = true;

          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          lastTouchDistance = Math.hypot(dx, dy);

          lastTouchMidpoint = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
          };
        } else if (e.touches.length === 1) {
          startX = e.touches[0].clientX - originX;
          startY = e.touches[0].clientY - originY;
          isDragging = true;
        }
      });

      mapContainer.addEventListener("touchmove", (e) => {
        if (e.touches.length === 2 && isTouchPanning) {
          e.preventDefault();

          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const newDistance = Math.hypot(dx, dy);

          const midpoint = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
          };

          const mapX = (midpoint.x - originX) / scale;
          const mapY = (midpoint.y - originY) / scale;

          const scaleFactor = newDistance / lastTouchDistance;
          scale *= scaleFactor;

          originX = midpoint.x - mapX * scale;
          originY = midpoint.y - mapY * scale;

          lastTouchDistance = newDistance;
          lastTouchMidpoint = midpoint;

          updateTransform();
        } else if (e.touches.length === 1 && isDragging) {
          originX = e.touches[0].clientX - startX;
          originY = e.touches[0].clientY - startY;
          updateTransform();
        }
      });

      mapContainer.addEventListener("touchend", (e) => {
        if (e.touches.length < 2) {
          isTouchPanning = false;
          lastTouchDistance = null;
        }
        if (e.touches.length === 0) {
          isDragging = false;
        }
      });

      // Static Noise Generator
      function generateNoise() {
        noiseCanvas.width = window.innerWidth;
        noiseCanvas.height = window.innerHeight;
        const id = noiseCtx.createImageData(
          noiseCanvas.width,
          noiseCanvas.height
        );
        for (let i = 0; i < id.data.length; i += 4) {
          const val = Math.random() * 255;
          id.data[i] = id.data[i + 1] = id.data[i + 2] = val;
          id.data[i + 3] = 20;
        }
        noiseCtx.putImageData(id, 0, 0);
      }

      setInterval(generateNoise, 60);
      window.addEventListener("resize", generateNoise);

      const distortionDuration = 1000; // 1 second
      const distortionInterval = 10000; // every 10 seconds
      let lastDistortionTime = 0;

      function animate(time = 0) {
        ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);

        // Apply zoom & pan transform
        ctx.save();
        ctx.translate(originX, originY);
        ctx.scale(scale, scale);

        // Draw map canvas content (already processed)
        ctx.drawImage(mapCanvas, 0, 0);

        ctx.restore();

        // Occasionally apply distortion effect on top of canvas
        if (time - lastDistortionTime > distortionInterval) {
          lastDistortionTime = time;
        }
        if (time - lastDistortionTime < distortionDuration) {
          applyDistortion(ctx, mapCanvas, time);
        }

        requestAnimationFrame(animate);
      }

      function applyDistortion(ctx, canvas, time) {
        const amplitude = 3; // max horizontal shift in px
        const frequency = 0.002; // speed of wave

        // Create a temporary canvas
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext("2d");

        // Draw current map onto temp canvas
        tempCtx.drawImage(canvas, 0, 0);

        // Clear main canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Slice and draw shifted lines
        const sliceHeight = 4;
        for (let y = 0; y < canvas.height; y += sliceHeight) {
          // Calculate horizontal offset as sine wave based on time and y pos
          const offsetX =
            Math.sin(y * 0.05 + time * frequency * 1000) * amplitude;

          // Draw slice shifted horizontally
          ctx.drawImage(
            tempCanvas,
            0,
            y,
            canvas.width,
            sliceHeight,
            offsetX,
            y,
            canvas.width,
            sliceHeight
          );
        }
      }
    </script>
  </body>
</html>
